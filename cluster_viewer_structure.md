# Image Cluster Viewer - Code Structure Documentation

This document provides a comprehensive overview of the Image Cluster Viewer application's structure, designed to help you understand the codebase organization and facilitate future refactoring.

## Table of Contents

1. [Project Overview](#project-overview)
2. [File Structure](#file-structure)
3. [Core Components](#core-components)
4. [Functional Areas](#functional-areas)
   - [CSV Processing and Data Management](#csv-processing-and-data-management)
   - [Cluster Visualization](#cluster-visualization)
   - [Navigation and Interaction](#navigation-and-interaction)
   - [Query and Filtering System](#query-and-filtering-system)
   - [Verification Workflow](#verification-workflow)
   - [Export Functionality](#export-functionality)
5. [Server-Side Components](#server-side-components)
6. [Potential Refactoring Opportunities](#potential-refactoring-opportunities)

## Project Overview

The Image Cluster Viewer is a web application for visualizing, analyzing, and verifying image clusters generated by clustering algorithms. It allows users to:

- Browse images grouped by cluster ID
- Query and filter images based on metadata
- Mark clusters as verified and identify duplicates
- Export verified clusters for further processing

The application is built with vanilla JavaScript, HTML, CSS, and a Node.js Express server.

## File Structure

```
cluster_viewer/
├── .gitignore           # Git ignore file
├── README.md            # Project documentation
├── index.html           # Main HTML structure
├── package.json         # Node.js dependencies
├── script.js            # Main entry point and application coordination
├── data.js              # Data processing and state management
├── ui.js                # UI components and rendering
├── features.js          # Application features and functionality
├── server.js            # Express server for serving files and images
├── styles.css           # CSS styling
├── cluster_viewer_structure.md  # Code structure documentation
└── refactoring_plan.md  # Refactoring plan documentation
```

## Core Components

### Application Architecture

The application follows a modular client-server architecture:

- **Client-side**:
  - HTML and CSS for structure and styling
  - Modular JavaScript organized into four main files:
    - `script.js`: Main entry point and coordination
    - `data.js`: Data processing and state management
    - `ui.js`: UI components and rendering
    - `features.js`: Application features and functionality
- **Server-side**: Node.js Express server for serving static files and images

### Global State Management

The application now uses a structured state management approach with all state variables encapsulated in the DataModule:

```javascript
// DataModule state object
DataModule.state = {
    // Cluster data
    allClusters: [],             // All loaded clusters
    currentPage: 0,              // Current page in pagination
    clustersPerPage: 30,         // Number of clusters per page
    selectedClusterId: null,     // Currently selected cluster for zoom view
    selectedClusterIndex: -1,    // Index of selected cluster
    isFilteringClusters: false,  // Whether filtering is active
    filteredClusters: [],        // Filtered subset of clusters

    // Verification state
    verifiedClusters: new Set(), // Set of verified cluster IDs
    nextVerifiedClusterId: 10000, // ID counter for new clusters
    originalToVerifiedMap: new Map(), // Map from image path to verified cluster ID
    imageVerificationStatus: new Map(), // Track verification status

    // Duplicate groups
    clusterDuplicateGroups: new Map(), // Map of duplicate groups by cluster
    duplicateGroupColors: [...],  // Colors for duplicate groups

    // Other state
    availableColumns: [],        // Columns from CSV
    currentQuery: null,          // Current query string
    currentImageIndex: -1,       // Current image index for modal
    currentClusterImages: []     // Images in current cluster for modal
}
```

### Initialization Flow

The application now initializes through a modular approach:

1. DOM content loaded event triggers the main `init()` function in `script.js`
2. The main init function initializes each module in sequence:
   - `DataModule.init()`: Initializes data structures and state
   - `UIModule.init()`: Initializes DOM elements and creates the modal
   - `FeaturesModule.init()`: Sets up keyboard navigation and other features
3. Event listeners are set up in the main script for user interactions
4. Each module handles its own specific initialization tasks:
   - UI module creates modal elements for image preview
   - Features module sets up keyboard event listeners
5. The application waits for user to upload a CSV file

## Functional Areas

### CSV Processing and Data Management

#### File Upload and Processing

The CSV processing workflow:

1. `handleFileUpload()` (Lines 197-212): Handles file selection and reads the file
2. `processCSVData()` (Lines 215-343): Parses CSV data and organizes images into clusters
3. `parseCSVLine()` (Lines 346-366): Helper function to parse CSV lines with quoted fields

Key aspects of data processing:

- Images are grouped by cluster ID ("component" column)
- Clusters with only one image are filtered out
- Clusters are sorted by size (largest first)
- Images within clusters are sorted by hashed_case_id when available

```javascript
// Example of cluster data structure
{
  id: "123",              // Cluster ID
  paths: [                // Array of image objects
    {
      path: "/path/to/image.jpg",
      name: "image.jpg",
      condition: "condition_value",
      hashedCaseId: "abc12",
      // Additional columns from CSV...
    },
    // More images...
  ]
}
```

### Cluster Visualization

#### Rendering Clusters and Images

The visualization system has two main display modes:

1. **Overview Mode**: Shows multiple clusters in a grid layout
2. **Zoom Mode**: Shows a single cluster with larger images and additional controls

Key functions:

- `displayCurrentPage()` (Lines 369-498): Manages which clusters to display based on current state
- `displayCluster()` (Lines 501-940): Renders a single cluster with its images
- `updateThumbnailSize()` (Lines 1112-1162): Adjusts image size based on slider value

The rendering process:

1. Clear the container
2. Determine which clusters to display (all or filtered)
3. If in zoom mode, display only the selected cluster
4. Otherwise, display clusters for the current page
5. Apply any active query highlights

#### Modal Image Preview

The application includes a modal for enlarged image viewing:

- Created during initialization (Lines 93-124)
- Opened when an image is clicked (Lines 819-830)
- Includes navigation between images in the same cluster (Lines 1182-1190)

### Navigation and Interaction

#### Pagination and Navigation

The application provides several navigation methods:

1. **Page Navigation**: For browsing through clusters in overview mode
   - `FeaturesModule.showPreviousPage()`
   - `FeaturesModule.showNextPage()`

2. **Cluster Navigation**: For moving between clusters in zoom mode
   - `FeaturesModule.navigateToAdjacentCluster()`
   - Arrow key navigation in `FeaturesModule.setupKeyboardNavigation()`

3. **Modal Navigation**: For browsing images in the modal view
   - `FeaturesModule.navigateModalImage()`
   - Arrow key navigation in `FeaturesModule.setupKeyboardNavigation()`

#### User Interaction Handling

The application sets up various event listeners during initialization:

- File upload handling (Line 127)
- Navigation buttons (Lines 128-129)
- Thumbnail size adjustment (Line 130)
- Query controls (Lines 131-139)
- Keyboard shortcuts (Lines 142-191)

### Query and Filtering System

#### Query Execution

The query system allows filtering images using JavaScript expressions:

1. `FeaturesModule.applyQuery()`: Parses and applies the query to all images
2. `UIModule.applyHighlightsToVisibleImages()`: Highlights matching images
3. `UIModule.updateClusterMatchCounts()`: Updates cluster headers with match counts

The query execution process:

1. Get the query string from the input field
2. Process each image in all clusters
3. Convert the query to a function that evaluates against image data
4. Store the match result in the image object
5. Update the UI to highlight matching images

#### Cluster Filtering

The application can filter clusters based on query results:

- `FeaturesModule.filterClusters()`: Shows only clusters with matching images
- Adds a "Clear Filter" button to return to the full view

### Verification Workflow

#### Image Selection

The verification workflow starts with selecting images:

- Checkboxes appear in zoom mode for image selection
- "Select All" checkbox for selecting all images in a cluster
- `FeaturesModule.updateButtonStates()`: Updates button states based on selection

#### Cluster Verification

The verification process:

1. `FeaturesModule.verifySelectedImages()`: Marks selected images as verified
2. Creates a new cluster for non-selected images if needed
3. Updates the UI to show verification status
4. `FeaturesModule.unverifyCluster()`: Removes verification status

#### Duplicate Management

The application allows marking duplicate images within clusters:

1. `FeaturesModule.markSelectedAsDuplicates()`: Groups selected images as duplicates
2. Assigns a color to each duplicate group for visual identification
3. `FeaturesModule.clearDuplicationMarks()`: Removes duplicate markings

### Export Functionality

The application can export verified clusters to a CSV file:

- `FeaturesModule.handleExportCsv()`: Creates CSV content with verification status
- `FeaturesModule.downloadCsv()`: Creates and triggers download of the CSV file

The exported CSV includes:
- Original image paths
- Updated cluster assignments
- Verification status
- Duplicate group information
- All original metadata columns

## Server-Side Components

### Express Server

The server component (`server.js`) handles:

1. Serving static files from the application directory
2. Serving images from their absolute paths
3. Automatically opening the browser when the server starts

Key features:

- Special route for serving images from absolute paths (Lines 20-43)
- Cross-origin resource sharing (CORS) enabled
- Command-line argument for custom port

## Implemented Refactoring and Future Opportunities

### Completed Refactoring

The application has been successfully refactored according to the plan:

#### 1. Modular Code Organization ✓
- Split the monolithic script.js into four specialized modules:
  - `data.js`: Data processing and state management
  - `ui.js`: UI components and rendering
  - `features.js`: Application features and functionality
  - `script.js`: Main entry point and coordination

#### 2. State Management Improvements ✓
- Replaced global variables with a structured state object in DataModule
- Implemented proper state access methods
- Improved state organization and encapsulation

### Future Refactoring Opportunities

While significant improvements have been made, there are still opportunities for further enhancement:

#### 1. UI Component Separation
- Further separate UI rendering into smaller, reusable components
- Create a more template-based approach for consistent rendering
- Consider implementing a simple component system

#### 2. Performance Optimizations
- Implement virtual scrolling for large clusters
- Add lazy loading for images
- Optimize query execution for large datasets
- Consider using Web Workers for heavy processing

#### 3. Error Handling and Validation
- Add more robust error handling for CSV parsing
- Validate user inputs and provide meaningful error messages
- Implement recovery mechanisms for failed operations

#### 4. Testing
- Add unit tests for each module
- Implement integration tests for key workflows
- Set up automated testing

By addressing these remaining opportunities, you can further enhance the maintainability, performance, and reliability of the application while building on the solid foundation established by the current refactoring.